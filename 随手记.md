#### 2020/12/9

Liunx下对函数hook时如何识别自身：  

Linux下采用修改got表方式进行hook，并且是将新的函数通过库加载到目标进程空间时，难免会遇到这样的问题：如果修改了自身的got表，那么调用被hook的函数就会进入死循环导致程序出错，如何识别自身就非常重要。  

##### 动态库识别自身镜像的方法

1,前面讲了获取*link_map*的方法，可以通过比对`link_map->l_name`来判断    

```c
struct link_map

 {

  /* These first few members are part of the protocol with the debugger.

    This is the same format used in SVR4. */

  ElfW(Addr) l_addr;  /* Difference between the address in the ELF

      file and the addresses in memory. */

  char *l_name;  /* Absolute file name object was found in. */

  ElfW(Dyn) *l_ld;  /* Dynamic section of the shared object. */

  struct link_map *l_next, *l_prev; /* Chain of loaded objects. */

 };
```

2,前面提到 *<link.h>*中导出了`_DYNAMIC`变量,这个变量标识的是当前镜像的动态段地址（当前是针对代码运行的位置而言的），可以做一个小小的测试。  

我们分别在一个动态库和程序主函数中输出`_DYNAMIC`变量，查看结果，就能验证上面所说的。  

有了上面的结论，只需要将动态库空间的这一变量保存下来，在hook的时候对比`link_map->l_ld`就能识别是否自身。  

#### 2020/12/7

Linux下获取动态段地址的方法：
1，通过*getauxval(AT_PHDR)*获取到phdr地址，再解析段表，获取到.dynamic段地址  
需要头文件  *#include <sys/auxv.h>*  
此方式的原理是读取 */proc/[pid]/auxv* 文件，更多详情：  

> man getauxval : [https://man7.org/linux/man-pages/man3/getauxval.3.html]( https://man7.org/linux/man-pages/man3/getauxval.3.html)  
> man proc : [https://linux.die.net/man/5/proc](https://linux.die.net/man/5/proc)

按照此原理，我们也能获取到其他程序的相关结构，前提是要知道pid

2,通过*_DYNAMIC*全局变量直接获取  
需要头文件  *#include<link.h>*  
此方式的原理为链接器在链接时使用此变量，但使用完之后没有清理，因此使用此方法获取的地址可能不是主程序的相关结构，而是正在链接的动态库的相关地址

> ps:通过动态段的内容还能获取到link_map等其他重要的程序动态链接相关数据结构
>

